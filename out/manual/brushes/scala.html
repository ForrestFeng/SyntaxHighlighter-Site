<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>NaN</title><script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script><meta charset="UTF-8">The partial "tracking" was not found, as such it will not be rendered.</head><body class="no_sponsor"><div id="title"><h1><a href="/SyntaxHighlighter">SyntaxHighlighter</a><span id="version"></span></h1><a id="forkme" href="https://github.com/alexgorbatchev/SyntaxHighlighter">Fork Me On GitHub</a><div id="whatsnew"><a href="/SyntaxHighlighter/whatsnew.html">whats new?</a></div><div id="blurb"><em>SyntaxHighlighter is an open source Java Script client side code syntax highlighter.</em></div><div id="meta"><a href="/SyntaxHighlighter/donate.html">donate</a><a href="/SyntaxHighlighter/download">download</a><a href="/SyntaxHighlighter/manual/installation.html">installation</a><a href="/SyntaxHighlighter/manual/api/autoloader.html">autoloader</a><a href="/SyntaxHighlighter/manual/configuration">configuration</a><a href="http://twitter.com/syntaxhighlight">syntaxhighlight</a></div><h2>Scala Example</h2></div><div id="content"><pre class="brush: scala">
package examples

/** Illustrate the use of pattern matching in Scala.
 *  Like patterns.scala, but uses extractors for representation independence
 */
object extractorPatterns {

  /** We need an abstract base class for trees. Subclasses with
   *  the 'case' modifier can be used in pattern matching expressions
   *  to deconstruct trees.
   *
   *  Here, we replaced case classes of patterns.scala with objects
   *  that hide the actual implementation of Branch and Leaf. Note
   *  that the remaining code does not change. In this way, we
   *  can change the implementation later without affecting clients,
   *  which is called representation independence.
   */
  abstract class Tree

  object Branch {
    /* method to contruct branches @see extractorPatterns.tree1 */
    def apply(left: Tree, right: Tree): Tree = new BranchImpl(left, right)
    /* extractor method referenced in match expressions @see extractorPatterns.sumLeaves */
    def unapply(x:Tree): Option[(Tree,Tree)] = x match {
      case y:BranchImpl => Some(y.left, y.right)
      case _            => None
    }
    private class BranchImpl(val left:Tree, val right:Tree) extends Tree
  }
  object Leaf {
    /* method to contruct leaves @see tree1 */
    def apply(x:Int): Tree = new LeafImpl(x);
    /* extractor method referenced in match expressions @see extractorPatterns.sumLeaves */
    def unapply(x:Tree): Option[Int] = x match {
      case y:LeafImpl => Some(y.x)
      case _          => None
    }
    private class LeafImpl(val x: Int) extends Tree
  }


  /** Case classes have an implicit constructor methods which allows
   *  to create objects withouth the 'new' keyword. It saves some typing
   *  and makes code clearer.
   *
   *  Here, the task of the case class constructor is performed by the
   *  method Branch.apply - the singleton Branch is treated as if it
   *  were a function value. This trick works with any value that has
   *  an apply method.
   */
  val tree1 = Branch(Branch(Leaf(1), Leaf(2)), Branch(Leaf(3), Leaf(4)))

  /** Return the sum of numbers found in leaves.
   *  'match' is a generalization of 'switch' in C-like languages
   *
   *  Patterns consist of case class constructors (which can
   *  be nested), and lower case variables which are
   *  bound to the values with which the class has been constructed.
   *
   *  For extractors, it is not the name of a case class, but the name of
   *  the singleton object Branch which is used to refer to its extractor method
   *  Branch.unapply - the pattern is the 'reverse' of a method
   *  call, with the result being matched in the subpatterns. This works
   *  for any value that has an appropriate extractor method.
   */
  def sumLeaves(t: Tree): Int = t match {
    case Branch(l, r) => sumLeaves(l) + sumLeaves(r)
    case Leaf(x) => x
  }

  /** This illustrates the use of Option types. Since the
   *  method is not known in advance to find 'x', the
   *  return type is an Option. Options have two possible
   *  values, either 'Some' or 'None'. It is a type-safe
   *  way around 'null' values.
   */
  def find[A, B](it: Iterator[Pair[A, B]], x: A): Option[B] = {
    var result: Option[B] = None
    while (it.hasNext &amp;&amp; result == None) {
      val Pair(x1, y) = it.next;
      if (x == x1) result = Some(y)
    }
    result
  }

  def printFinds[A](xs: List[Pair[A, String]], x: A) =
    find(xs.elements, x) match {
      case Some(y) => println(y)
      case None => println("no match")
    }

  def main(args: Array[String]) {
    println("sum of leafs=" + sumLeaves(tree1));
    printFinds(List(Pair(3, "three"), Pair(4, "four")), 4)
  }
}
</pre>

<p>The partial &quot;brushes&quot; was not found, as such it will not be rendered.</p>
</div><div id="clear"></div><div id="copyright"><div>SyntaxHighlighter was originally created in 2004 and is still maintained by Alex Gorbatchev.</div><div>Copyright 2004-2014 Alex Gorbatchev.</div></div><div id="footer"><div id="ad"><script>google_ad_client = "ca-pub-2888483682038752";
/* SyntaxHighlighter2 */
google_ad_slot = "1794546701";
google_ad_width = 160;
google_ad_height = 600;</script><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div><a href="/SyntaxHighlighter/about.html">about</a><a href="/SyntaxHighlighter/manual/brushes/">syntaxes</a><a href="/SyntaxHighlighter/manual/themes/">themes</a><a href="/SyntaxHighlighter/integration.html">integration</a><a href="/SyntaxHighlighter/hosting.html">hosting</a><a href="/SyntaxHighlighter/manual/older_versions.html">legacy</a><a href="/SyntaxHighlighter/manual/api">apis</a><a href="https://github.com/alexgorbatchev/SyntaxHighlighter/issues">issues</a><a href="https://github.com/alexgorbatchev/SyntaxHighlighter">source</a><a href="https://github.com/alexgorbatchev/SyntaxHighlighter-Site">site</a><a href="/SyntaxHighlighter/contact.html">contact</a></div></body><link type="text/css" rel="stylesheet" href="/SyntaxHighlighter/css/main.css"><link type="text/css" rel="stylesheet" href="/sh_pub/styles/shCore.css"><link type="text/css" rel="stylesheet" href="/sh_pub/styles/shThemeDefault.css"><script type="text/javascript" src="/sh_pub/scripts/shCore.js"></script><script type="text/javascript" src="/sh_pub/scripts/shAutoloader.js"></script><script type="text/javascript" src="/sh_pub/scripts/shBrushXml.js"></script><script type="text/javascript" src="/sh_pub/scripts/shBrushJScript.js"></script><script type="text/javascript" src="/sh_pub/scripts/shBrushCss.js"></script><script type="text/javascript" src="/SyntaxHighlighter/scripts/main.js"></script>The partial "services" was not found, as such it will not be rendered.</html>